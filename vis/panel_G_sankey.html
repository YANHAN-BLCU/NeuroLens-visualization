<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桑基图 - 越狱样本溯源路径</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            padding: 16px;
            background-color: #ffffff;
            height: 100vh;
            overflow: auto;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
        }

        button {
            padding: 6px 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #1d4ed8;
        }

        button.secondary {
            background: #64748b;
        }

        button.secondary:hover {
            background: #475569;
        }

        #sankey-chart {
            width: 100%;
            height: calc(100vh - 120px);
            min-height: 300px;
        }
    </style>
</head>
<body>
    <div class="panel-header">
        <div class="panel-title" data-i18n="sankey_title">样本溯源视图 G</div>
    </div>
    
    <div id="sankey-chart"></div>

    <script>
        // Translations
        const translations = {
            en: {
                sankey_title: "Sample Origin View G",
                loading: "Loading data...",
                reload: "Reload",
                ok_data_loaded: "Data loaded! Nodes:",
                connections: "connections",
                error_load_failed: "Load failed:",
                title_real: "Jailbreak Sample Tracing Path"
            },
            zh: {
                sankey_title: "样本溯源视图 G",
                loading: "正在加载数据...",
                reload: "重新加载",
                ok_data_loaded: "数据加载成功！节点:",
                connections: "连接",
                error_load_failed: "加载失败:",
                title_real: "越狱样本溯源路径"
            }
        };

        // Get saved language
        let currentLang = localStorage.getItem('language') || 'zh';

        // Update language
        function updateLanguage(lang) {
            currentLang = lang;
            const t = translations[lang] || translations.zh;
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });
            
            // Reload chart with new language
            if (window.chartData) {
                const plotlyData = convertToPlotlyFormat(window.chartData);
                Plotly.newPlot('sankey-chart', [plotlyData], {
                    title: t('title_real'),
                    font: { size: 12 },
                    paper_bgcolor: "white",
                    plot_bgcolor: "white",
                    margin: { l: 10, r: 10, t: 40, b: 10 }
                }, {responsive: true});
            }
        }

        // Listen for language changes from parent
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'languageChange') {
                updateLanguage(event.data.lang);
            }
        });

        const API_BASE_URL = 'http://localhost:5000';
        
        function t(key) {
            return translations[currentLang][key] || translations.zh[key] || key;
        }
        
        // Load real data from API
        async function loadData() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/attack_paths`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Store data for language switching
                window.chartData = data;
                
                const plotlyData = convertToPlotlyFormat(data);
                
                Plotly.newPlot('sankey-chart', [plotlyData], {
                    title: t('title_real'),
                    font: { size: 12 },
                    paper_bgcolor: "white",
                    plot_bgcolor: "white",
                    margin: { l: 10, r: 10, t: 40, b: 10 }
                }, {responsive: true});
                
            } catch (error) {
                console.error('Load failed:', error);
            }
        }

        // Convert to Plotly Sankey format
        function convertToPlotlyFormat(data) {
            const nodes = data.nodes || [];
            const links = data.links || [];
            
            const labels = nodes.map(n => n.label);
            const colors = nodes.map(n => {
                const type = n.type || 'other';
                const colorMap = {
                    'attack': '#EEC79F',
                    'quadrant': '#74B69F',
                    'output': n.label === 'Jailbroken' ? '#A6CDE4' : '#E2C8D8'
                };
                return colorMap[type] || '#F1DFA4';
            });
            
            const sources = links.map(l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                return nodes.indexOf(sourceNode);
            });
            
            const targets = links.map(l => {
                const targetNode = nodes.find(n => n.id === l.target);
                return nodes.indexOf(targetNode);
            });
            
            const values = links.map(l => l.value || 1);
            const linkColors = links.map(l => l.color || 'rgba(168, 168, 168, 0.3)');
            
            return {
                type: "sankey",
                node: {
                    pad: 12,
                    thickness: 18,
                    line: {
                        color: "black",
                        width: 0.5
                    },
                    label: labels,
                    color: colors
                },
                link: {
                    source: sources,
                    target: targets,
                    value: values,
                    color: linkColors
                }
            };
        }

        // Page load - auto load data
        window.onload = function() {
            updateLanguage(currentLang);
            loadData();
        };
    </script>
</body>
</html>
